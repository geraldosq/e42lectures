	\documentclass[12pt]{article}
	\usepackage[a4paper,bindingoffset=0.2in,left=1.2in,right=0.98in,top=1.2in,bottom=0.98in,footskip=.25in]{geometry}
	% Esto es para poder escribir acentos directamente:
	%\usepackage[latin1]{inputenc}
	% Esto es para que el LaTeX sepa que el texto está en español:
	\usepackage[english]{babel}
	\usepackage[utf8]{inputenc}
	\usepackage{hyperref}% http://ctan.org/pkg/hyperref
	%\usepackage{makeidx}
	\usepackage{import}
	\usepackage{example}
	\usepackage{amsmath}
	\usepackage{amsfonts}
	\usepackage{verbatim}
	\usepackage{graphicx}
	\graphicspath{ {../../images/} }
	\usepackage{titlesec,lipsum}
	\titleformat{\chapter}[display]{\normalfont\huge\bfseries}{\chaptertitlename\ \thechapter}{20pt}{\Huge}
%	\usepackage[style=authoryear,backend=bibtex]{biblatex} %backend tells biblatex what you will be using to process the bibliography file
	\usepackage{filecontents}
	%\usepackage{setspace}
	%\renewcommand{\baselinestretch}{1.5}
	%\usepackage{helvet}
	%\renewcommand{\familydefault}{\sfdefault}
%	\usepackage[usenames]{color}



%opening
\label{2}
\title{Concepts in programation}
	\author{Gerald Salazar Quiroz \\
	  Universidad Nacional de Ingeniería \\
	  MINER$\nu$A Experiment \\
	  AMANCAES i+d+i}


\begin{document}
\maketitle
\newpage

\tableofcontents
\newpage

\chapter{Big concepts}


\chapter{Classes}
\import{section/}{classes.tex}



\section{Pointers}
\label{pointers.concepts}


	A pointer is a memory address. It is not a variable, its contents is the
	address of the variable that its points, at which the pointer is referred.

	\textbf{Name, reference, alias, pointer and array}: Variable gives an object a \textsl{name}, a reference is an \textsl{alias} for an object, while the pointer is an \textbf{object that referers to another object}. Finally an \textsl{array} is a linear sequence of object of the same type.

	\begin{itemize}
	\item If you need an object a pointer is pointing to, you have to use the dereferencing operator *, *p means the object p is pointing to.
	\item If you need the the address of an object e.g. to initialize an pointer, you have to use the address operator \verb"&", \verb"&o" means the address of object o.
	\end{itemize}


	\textbf{Why we use pointers, anyway}?

	Pointers allow for the program does not care about the physical address of the data in memory, it simply uses the identifier whenever it needs to refer to the variable.


	\subsection{Pointers in C}

	How is defined?: 

	\begin{verbatim}
	int *foo_ptr = &foo
	\end{verbatim}

	The operator \verb|&|  extract the value of the address in the memory of
	 the variable. \verb|foo_ptr| is declared as a pointer to int. You could put
	a different pointer in the \verb|foo_ptr| box, and the
	box would still be \verb|foo_ptr|, but it would no longer point to foo.


	Say you declare a variable named foo.

	\begin{verbatim}
	int foo;
	\end{verbatim}

	This variable occupies some memory. On current mainstream Intel processors,
	it occupies four bytes of memory (because an int is four bytes wide). Now let's declare another variable.

	\begin{verbatim}
	int *foo_ptr = &foo;
	\end{verbatim}

	\verb|foo_ptr| declared as pointer to \verb|int|. We have initialized it to point to \verb|foo|.

	\verb|foo| occupies some memory. Its location in memory is called its address \verb|&foo| is
	the address of  \verb|foo| (which is why is \verb|&| called the \verb|address-of operator|.


	Think of every variable as a box. \verb|foo| is a box that is \verb|sizeoff(int)| bytes in size. The location of this boz is its address. When you acces the address, you actually access the contents of the box it points to.


	\begin{figure}[h]
	\includegraphics[scale=1]{boxes_pointer.png}
	\centering
	\end{figure}


	\subsection{Pointer Syntaxis in C}

	Declaration two pointer variables in a single declaration is:
	\begin{verbatim}
	int *foo_ptr = &foo //for only one pointer
	int* ptr_a, ptr_b;
	\end{verbatim}

	If the type of a variable containing a pointer to \verb|int| is \verb|int *|.
	All of those this are right:


	\begin{verbatim}
	int *ptr_a;
	int   ptr_b;
	\end{verbatim}
	Think of it as assigning each variable a base type (int), plus a level of indirection, indicated by the number of asterisks \verb|(ptr_b's is zero;ptr_a's is one)|.

	In a single-line declaration in a clear way.

	\begin{verbatim}
	int *ptr_a, ptr_b;
	\end{verbatim}

	\subsection{Pointers in C++}

	Variables have been explained as locations in the computer's memory which can be accessed by their identifier (their name). But also we can access to the value knowing the address of the varible. 


	\subsection{Declaring pointers in C++}


	Variables have been explained as locations in the computer's memory which can be accessed by their identifier (their name).

	In C++ program , the memory of a computer is like a succession of a memory cells, each one byte in size, and each with a unique address. 

	\subsection{Declaring pointers in C++}
	The address of a variable can be obtained by preceding the name of a variable with an ampersand sing (\verb|&|), know as address-of operator. 

	\begin{verbatim}
	foo = &myvar; 
	\end{verbatim}

	Consider that the address of a variable in memory is 1776. 

	\begin{verbatim}
	myvar = 25;
	foo = &myvar;
	bar = myvar;
	\end{verbatim}

	Whe have the following assigments: 

	\begin{itemize}
	\item The value of \verb|myvar| is 25. 
	\item  The second statement assign the value of foo as the address of the variable foo, which is 1776. 
	\item Assigns the value contained in \verb|myvar| to \verb|bar|. 
	\end{itemize}

	\subsection{Dereference operator *}

	An interesting property of pointers is that they can be used to access the variable opint to directly\footnote{\url{http://www.cplusplus.com/doc/tutorial/pointers/}}. 

	\begin{verbatim}
	baz = *foo; 
	\end{verbatim}

	This could be read as: \verb|baz| equal to value pointed to by \verb|foo| and the statement would actually assign the value 25 to \verb|baz|, since \verb|foo| is 1776. 


	%image dereference_operator.png


	The reference and dereference operators are thus complementary:
	\begin{itemize}
	\item \verb|&| is the address-of operator, and can be read simply as "address of".
	\item \verb|*| is the dereference operator, and can be read as "value pointed to by". 

	\subsection{Declaring pointers}

	The declaration of pointers follows this syntax: 

	\begin{verbatim}
	int * number; 
	char * character; 
	double * decimals; 
	\end{verbatim}

	Some words must be said: 
	\begin{itemize}
	\item Three declarations of pointers.
	\item All will occupy the same amount of memory.
	\item The variables at which they point will ocuppy differents values of memory.
	\item The first point to an \verb|int|, the second to a \verb|char| adn the last one to a \verb|double|. 
	\end{itemize}

	\begin{verbatim}
	"Note that the asterisk (*) used when declaring a pointer only means that it is a pointer (it is part of its type compound specifier), and should not be confused with the dereference operator seen a bit earlier, but which is also written with an asterisk (*). They are simply two different things represented with the same sign."
	\end{verbatim}

		\subsubsection{Example of code with pointers}

		\begin{verbatim} 
		// my first pointer
		#include <iostream>
		using namespace std;

		int main ()
		{
		  int firstvalue, secondvalue;
		  int * mypointer;

		  mypointer = &firstvalue;
		  *mypointer = 10;
		  mypointer = &secondvalue;
		  *mypointer = 20;
		  cout << "firstvalue is " << firstvalue << '\n';
		  cout << "secondvalue is " << secondvalue << '\n';
		  return 0;
		}
		\end{verbatim}

		A pointer declaration is any simple declaration whose declarator has the form


		%declarator_pointer.png

		\subsubsection{Pointer to object initialized with the return value of the address-of operator}
		Reference in\footnote{\url{http://en.cppreference.com/w/cpp/language/pointer}} 

		\begin{verbatim}
		int n;
		int* np = &n; // pointer to int
		int* const * npp = &np; // non-const pointer to const pointer to non-const int
		 
		int a[2];
		int (*ap)[2] = &a; // pointer to array of int
		 
		struct S { int n; };
		S s = {1};
		int* sp = &s.n; // pointer to the int that is a member of s
		\end{verbatim}

		\subsubsection{Pointers as operands to the built-in indirection operator}

		\begin{verbatim}
		int n;
		int* p = &n;     // pointer p is pointing to n
		int& ref = *p;   // the lvalue expression that identifies n is bound to a reference
		ref = 7;         // stores 7 in n
		std::cout << *p; // lvalue-to-rvalue conversion reads the value from n
		\end{verbatim}

		\subsubsection{Pointers to class in the left-hand operands of the member access}

		\begin{verbatim}
		int a[2];
		int *p = a; // pointer to a[0]
		 
		int b[3][3];
		int (*row)[3] = b; // pointer to b[0]
		\end{verbatim}

	\subsection{Pointer initialization}

	Pointers can be initialized to point to specific locations at the very moment they are defined:

	\begin{verbatim}
	int myvar; 
	int * myptr = &myvar; 
	\end{verbatim}

	As always, spaces are not relevant, and never change the meaning of an expression.

	Pointers can be initialized either to the address of a variable (such as in the case above), or to the value of another pointer (or array):

	\begin{verbatim}

	int myvar;
	int *foo = &myvar;
	int *bar = foo;
	\end{verbatim}

	\subsection{What is the right way o write: char * p or char *p}

	nceThere are two usual ways of coding:
	\begin{verbatim}
	char* p;
	char *p;
	\end{verbatim}

	Look the difference in order of the \verb|*|. There is a discussion if this is okey. The creator of C++ says this:

	\begin{itemize}
	\item The choice between \verb|int* p| and \verb|int *p| is not about wrong or right.
	\item C emphasized \textbf{expressions}, declarations were considered as a necessary evil.
	\item C++ has a emphasis on \textbf{types}.
	\item C programmer writes \verb|int *p;| emphasizinf syntax: \verb|*p is what is the int|. (*p es lo que int es).  The *binds to the name p in the grammar.
	\item C++ programmer writes \verb|int* p| and explains it \verb|p is a pointer to an int| (p es un puntero hacia un int). Indeed the type of a p is int*.

	\end{itemize}

	%ftp://root.cern.ch/root/doc/ROOTUsersGuideHTML/ch11s04.html


	Say you declare a variable named foo.

	\begin{verbatim}
	int foo;
	\end{verbatim}

	This variable occupies some memory, 4 bytes of
	memory because an int is four vytes wide.

	\begin{verbatim}
	int *foo_ptr= &foo;
	\end{verbatim}

	\verb|foo_ptr| is declared as pointer to \verb|int|. We have initialized it to point to \verb|foo|.


	\newpage
	\chapter{ROOT}

	\section{Pointers in ROOT}



	[CODES in ROOT]

		\subsubsection{Alias  working with TDatime class}


		\begin{verbatim}

		TDatime now;
		now.Print();
		\\Create an object type TDatime, call its Print() method
		TDatime & date = now;
		\\Create an alias name "date" for objet now, uses its Print() methods. \\Same result.
		now.Set(now.GetDate()-1,0)
		now.Print()
		\\Change object now, Print()
		date.Print()
		\\date.Print() gives the same result, date and now are two names for the same object.
		TDatime & test;
		\\A declaration of a reference(i.e. an alias) must specify the object for which an alias should be created, otherwise the declaration is an error.
		\end{verbatim}

	\subsection{Pointers using the class TDatime }

	\begin{verbatim}
	TDatime now;
	TDatime *p;
	\\Declare a pointer to a TDatime object, name it p
	p=&now ;
	\\ Set the pointer p to the address of the object now
	p->Print();
	\\ Call the print() method of the object p is pointing to
	(*p).Print();
	\\Call the method Print() of the object  *p. *p is the object p is pointing to.
	\end{verbatim}

	\subsection{Get pointers to the TTrees in each file - Print ()}
	Get the pointers to the TTrees in each file, then Print() it

	\begin{verbatim}

	for i=1 to #NumberOfFiles do;
	TFile signal("root_file.root");
	TTree * mysignalTree[i] = (TTree*)signal.Get("SelectedTree");
	end if

	\end{verbatim}




	Symbol \verb|->| instead of the period \verb|.| to issue tge commands to the TTree.
	Why? because tree1 is not a TTree itself
	Examples


	\begin{verbatim}


	TH1D hist1("h1","a histogram", 100, -3,3);

	// creates a new histogram in ROOT and the name of the "histogram object" is hist1 //
	// period "." for objects; "->" for pointers //

	hist1.Draw();

	TH1D *hist1 = new TH1D("h1","a histogram", 100,-3,3);
	//hist1 is not a "histogram object" is a histogram pointer //
	hist1->Draw();

	\end{verbatim}

\chapter{Codes}

\section{Arrays}
\label{pointers.codes}

	An arrays is a series of elements of the same type places in contiguous memory locations that can be individually referenced by adding an indes to a unique identifier. 

	That means that, for example, five values of type \verb"int" can be declared as an array without having to declare 5 different variables (each with its own identifier). 

	For example, an array containing 5 interger values of type \verb"int" called \verb"foo" could be represented as: 


	\begin{figure}[h]
	\includegraphics[scale=1]{arrays1.png}
	\centering
	\end{figure}

	where each blank panel represents an element of the arrays. In this case, these are values of type \verb"int". These elements are numbered from 0 to 4, being 0 the first and 4 last; in C++, the first element in the array is always numbered with a zero (not a one), no matter its length. 


	\subsection{Arrays in C++}


		Like a regular variable, an array must be declared before it is used. A typical declara
		\begin{verbatim}
		type name [elements]; 
		\end{verbatim}
		where \verb"type" is a valid type (such as \verb"int", \verb"float", ...), \verb"name",  is a valid identifier and the \verb"elements" field (which is always enclosed in squared brackets []), specifies the length of the array in terms of the number of elements. 

		Therefore, the \verb"foo" array, with five elements of type \verb"int", can declared as: 

		\begin{verbatim}
		int foo [5]; 
		\end{verbatim}


		\subsubsection{Initializing arrays}

			By default, regular arrays of local scope (for example, those declared within a function) are left uninitialized. This means that none of its elements are set to any particular value; their contents are undetermined at the point the arrays is declared. 

			But the elements in an array can be explicitly initialized to specified values when it is declared, by enclosing those initial values in braces\{ \}. 

			\begin{verbatim}
			int bar [5] = {10,20,30};
			\end{verbatim}

			Adoption of universal initialization also for arrays. Therefore, there is no longer need for the equal sign betwenn the declaration and the initializer. Both these statements are equivalent: 

			\begin{verbatim}
			int foo[] = {10,20,30};
			int foo[] {10,20,30};
			\end{verbatim}


		\subsubsection{Accessing the values of an array}

			The values of any of the elements in an array can be accessed just like the value of a regular variable of the same type. 

			\begin{verbatim}
			name[index]
			\end{verbatim}

			In the previous example, the following statement stores the value 75 in the third element of foo: \verb|foo [2] = 75|


			\begin{verbatim}
				// arrays example
				#include <iostream>
				using namespace std;

				int foo [] = {16, 2, 77, 40, 12071};
				int n, result=0;

				int main ()
				{
				  for ( n=0 ; n<5 ; ++n )
				  {
				    result += foo[n];
				  }
				  cout << result;
				  return 0;
				}			
			\end{verbatim}

		
		\subsubsection{Arrays as parameters}
			At some point, we may need to pass an array to a function as a parameter. In C++, it is not possible to pass the entire block of memory represented by an array to a function directly as an argument. But what can be passed instead is its address. In practice, this has almost the same effect, and it is much faster and more efficient operation. 

			To accept an array as parameter for a function, the parameters can be declared as the array type, but with empty brackets, omitting the actual size of the array. For example

			\begin{verbatim}
			void procedure (int arg[])
			\end{verbatim}

			this function accepts a parameter of type "array of int" called arg. In order to pass to this function an array declared as: 

			\begin{verbatim}
			int myarray [40]; 
			\end{verbatim}

			it would be enouh to write a call like this: 

			\begin{verbatim}
			procedure (myarray);
			\end{verbatim}

			An example: 


			\begin{verbatim}
			// arrays as parameters
			#include <iostream>
			using namespace std;

			void printarray (int arg[], int length) {
			  for (int n=0; n<length; ++n)
			    cout << arg[n] << ' ';
			  cout << '\n';
			}

			int main ()
			{
			  int firstarray[] = {5, 10, 15};
			  int secondarray[] = {2, 4, 6, 8, 10};
			  printarray (firstarray,3);
			  printarray (secondarray,5);
			}
			\end{verbatim}

			In the code above, the first parameter (int arg[]) accepts any array whose elements are of type int, whatever its length. For that reason, we have included a second parameter that tells the function the length of each array that we pass to it as its first parameter. This allows the for loop that prints out the array to know the range to iterate in the array passed, without going out of range.


		\subsubsection{Library arrays}
		\subsubsection{Initializing arrays}



\import{section/}{Inpuouput.tex}
\label{inputoutput.concepts}
\import{section/}{ObjectOrientedProgramming.tex}
\label{objectedorientedprogramming.concepts}

\end{document}






